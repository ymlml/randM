
import os, sys
import numpy as np
import cv2
import matplotlib.pyplot as plt
import random
import math

print(math.exp(-0.5))

#inverse sampling: generate samples that obey f(x)=x+0.5, based on uniform distributin samples in U(0,1) 
#cumulative distribution function F(x)=0.5*x*(x+1); 
#cdf's inverse function F^-1(x)=sqrt(2x+0.25)-0.5;
#if v~U(0,1) (generated by random.random), u=F^-1(v)~ f(x)=x+0.5 (in list a)
a = []
for i in range(0,100000):
    tmp = random.random()
    tmp = math.sqrt(tmp*2+0.25) - 0.5 
    a.append(tmp)

#generating uniform distribution samples using the samples from distribution f(x)=x+0.5
#if u~f(x)=x+0.5 (in list a), then v=F(u)~U(0,1) (in list b)
b = []
for num in a:
    tmp = 0.5*num*(num+1)
    b.append(tmp)

#same thing by numpy
#a = np.random.rand(100000)
#a = np.sqrt(a*2+0.25) - 0.5
#b = 0.5*a*(a+1)

plt.figure(1)
plt.hist(b, 100)
plt.figure(2)
plt.hist(a, 100)
#plt.show()

#compute normal distribution function value at x
def my_normal_p(x, mu, sigma):
    return math.exp(-(x-mu)*(x-mu)/(2*sigma*sigma)) / (math.sqrt(2*math.pi)*sigma)

#genrate an uniform distribution sample, from U(a, b)
def my_one_uniform_sample(a,b):
    #return a*2*(random.random()-0.5)
    return random.uniform(a,b)

#genrate a gaussian distribution sample, from N(a, b^2)
def my_one_gaussian_sample(a,b):
    return random.gauss(a,b)

#rejective sampling: generate stardard normal distribution sampels based on samples in U(0,1)
c = []
for i in range(0,100000):
    tmp = my_one_uniform_sample(-5,5)
    p = random.random()/(math.sqrt(2*math.pi))
    acc_thres = my_normal_p(tmp,0,1)
    if p<acc_thres:
        c.append(tmp)

#compare with the api
d = []
for i in range(0, len(c)):
    d.append(random.gauss(0,1))

plt.figure(4)
plt.hist(d, 100)
plt.figure(3)
plt.hist(c, 100)
#plt.show()

#Metropolis algorithm: generate normal distribution N(1,1) with proposal distribution U(-5,5)
e = []
z_tau = my_one_uniform_sample(-5,5)
e.append(z_tau)
for i in range(0,100000):
    z_star = my_one_uniform_sample(-5,5)
    acc_thres = min( 1, my_normal_p(z_star,1,1)/my_normal_p(z_tau,1,1) )
    u = random.random()
    if u<acc_thres:
        e.append(z_star)
        z_tau = z_star
    else:
        e.append(z_tau)

plt.figure(5)
plt.hist(e, 100)

#Metropolis algorithm: generate normal distribution N(1,1) with proposal distribution N(0,1)
#q(z_star|z_tau) is chosen to be gaussian centered on z_tau, as in page 541
f = []
#z_tau = -10
z_tau = my_one_gaussian_sample(0,1)
f.append(z_tau)
for i in range(0,100000):
    z_star = my_one_gaussian_sample(z_tau,1) #sample from q(z_star|z_tau)
    acc_thres = min( 1, my_normal_p(z_star,1,1)/my_normal_p(z_tau,1,1) )
    u = random.random()
    if u<acc_thres:
        f.append(z_star)
        z_tau = z_star
    else:
        f.append(z_tau)

plt.figure(6)
plt.hist(f, 100)
plt.show()

